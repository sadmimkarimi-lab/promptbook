<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>عنوان کتاب شما</title>

  <!-- فونت وزیر -->
  <link href="https://cdn.jsdelivr.net/gh/rastikerdar/vazir-font@v30.1.0/dist/font-face.css" rel="stylesheet" />

  
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: Vazir, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5; /* پس‌زمینه روشن */
      color: #111827;      /* متن مشکی/تیره */
    }

    .page {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px 16px 40px;
    }

    /* هدر / کاور کتاب */
    .hero {
      display: flex;
      gap: 16px;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    .hero-cover {
      width: 180px;                 /* عرض قاب */
      aspect-ratio: 464 / 600;      /* نسبت واقعی جلد */
      border-radius: 16px;
      overflow: hidden;
      background: #e5e7eb;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    .hero-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;            /* بدون کشیدگی */
    }

    .hero-text {
      flex: 1;
      min-width: 200px;
    }

    .hero-text h1 {
      margin: 0 0 8px;
      font-size: 24px;
    }

    .hero-text p {
      margin: 0;
      font-size: 14px;
      color: #4b5563;
      line-height: 1.9;
    }

    /* فهرست کلی */
    .toc {
      background: #ffffff;
      border-radius: 18px;
      padding: 16px 14px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      margin-bottom: 24px;
      border: 1px solid #e5e7eb;
    }

    .toc h2 {
      margin: 0 0 12px;
      font-size: 18px;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 6px;
    }

    .toc-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .toc-chapter {
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px dashed #e5e7eb;
    }

    .toc-chapter:last-child {
      border-bottom: none;
    }

    .toc-chapter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      padding: 6px 2px;
    }

    .toc-chapter-title {
      font-size: 15px;
      font-weight: 600;
    }

    .toc-chapter-toggle {
      font-size: 18px;
      line-height: 1;
      user-select: none;
      color: #6b7280;
    }

    .toc-section-list {
      list-style: none;
      padding: 4px 8px 4px 0;
      margin: 0;
      display: none;
    }

    .toc-chapter.open .toc-section-list {
      display: block;
    }

    .toc-section-item {
      margin-bottom: 4px;
    }

    .toc-btn {
      width: 100%;
      text-align: right;
      border: none;
      background: transparent;
      color: #111827;
      padding: 6px 6px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 999px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .toc-btn span {
      flex: 1;
    }

    .toc-btn small {
      font-size: 11px;
      color: #9ca3af;
      white-space: nowrap;
    }

    .toc-btn:hover {
      background: #f3f4f6;
    }

    .toc-btn.active {
      background: #111827;
      color: #f9fafb;
    }

    /* فصل‌ها و متن */
    .chapters {
      margin-top: 10px;
    }

    .chapter {
      background: #ffffff;
      border-radius: 18px;
      padding: 14px 14px 10px;
      margin-bottom: 14px;
      border: 1px solid #e5e7eb;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.04);
    }

    .chapter-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      cursor: pointer;
    }

    .chapter-title {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
    }

    .chapter-toggle {
      font-size: 18px;
      line-height: 1;
      user-select: none;
      color: #6b7280;
    }

    .chapter-body {
      margin-top: 10px;
      font-size: 14px;
      color: #111827;
      line-height: 2;
      display: none; /* اول بسته */
      max-height: 65vh;
      overflow-y: auto;
      padding-top: 4px;
      border-top: 1px solid #e5e7eb;
    }

    .chapter.active .chapter-body {
      display: block;
    }

    .section {
      margin-bottom: 18px;
    }

    .section-title {
      font-size: 15px;
      margin: 0 0 6px;
      font-weight: 600;
    }

    .section p {
      margin: 0 0 8px;
      text-align: justify;
    }

    @media (max-width: 600px) {
      .hero {
        flex-direction: row;
        align-items: flex-start;
      }

      /* فقط عرض رو کوچیک می‌کنیم، height رو دست نمی‌زنیم */
      .hero-cover {
        width: 150px;
      }

      .hero-text h1 {
        font-size: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="page">

    <!-- هدر و کاور کتاب -->
    <header class="hero">
      <div class="hero-cover">
        <!-- عکس جلد کتاب -->
        <img src="https://cdnfa.com/irangiah/a9be/uploads/ketab/propm.webp" alt="جلد کتاب">
      </div>

      <div class="hero-text">
        <h1>عنوان کتاب شما</h1>
        <p>
          اینجا یک توضیح کوتاه درباره کتاب می‌نویسی؛ مثلاً موضوع کلی، مخاطب کتاب
          و این‌که قرار است خواننده چه چیزی از این کتاب بگیرد.
        </p>
      </div>
    </header>

    <!-- فهرست: فصل‌ها + مبحث‌ها -->
    <section class="toc">
      <h2>فهرست</h2>
      <ul class="toc-list">

        <!-- فصل اول -->
<li class="toc-chapter" data-chapter="chapter-1">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل اول: پرامپت‌نویسی چیست و مدل چگونه کار می‌کند؟</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-1">
        <span>مبحث ۱: مقدمه – پرامپت و نقش آن</span>
        <small>صفحات ۶–۷</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-2">
        <span>مبحث ۲: مدل‌های زبانی چگونه پاسخ می‌سازند؟</span>
        <small>صفحات ۷–۹</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-3">
        <span>مبحث ۳: پرامپت‌نویسی یعنی طراحی یک مسیر واضح</span>
        <small>صفحات ۹–۱۰</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-4">
        <span>مبحث ۴: تنظیمات مدل و کنترل خروجی</span>
        <small>تقریباً صفحات ۱۰–۱۳</small>
      </button>
    </li>
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-1"
              data-section="section-1-5">
        <span>مبحث ۵: جمع‌بندی فصل اول</span>
        <small>مرور کلی</small>
      </button>
    </li>
  </ul>
</li>

        <!-- فصل دوم -->
<li class="toc-chapter" data-chapter="chapter-2">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل دوم: تکنیک‌های پرامپت‌نویسی</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-1">
        <span>مبحث ۱: Zero-shot Prompting</span>
        <small>صفحات ۱۳–۱۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-2">
        <span>مبحث ۲: One-shot & Few-shot</span>
        <small>صفحات ۱۵–۱۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-3">
        <span>مبحث ۳: System Prompting</span>
        <small>صفحات ۱۸–۲۱</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-4">
        <span>مبحث ۴: Role Prompting</span>
        <small>صفحات ۲۱–۲۳</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-5">
        <span>مبحث ۵: Contextual Prompting</span>
        <small>صفحات ۲۳–۲۵</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-2"
              data-section="section-2-6">
        <span>مبحث ۶: جمع‌بندی فصل دوم</span>
        <small>مرور</small>
      </button>
    </li>
  </ul>
</li>

        <!-- فصل سوم -->
<li class="toc-chapter" data-chapter="chapter-3">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل سوم: تکنیک‌های استدلال و تولید پاسخ هوشمند</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-1">
        <span>مبحث ۱: مقدمه – چرا به استدلال نیاز داریم؟</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-2">
        <span>مبحث ۲: Step-back Prompting</span>
        <small>صفحات ۲۵–۲۷</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-3">
        <span>مبحث ۳: Chain-of-Thought (زنجیرهٔ تفکر)</span>
        <small>صفحات ۲۷–۳۰</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-4">
        <span>مبحث ۴: Self-consistency reasoning</span>
        <small>صفحات ۳۰–۳۲</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-5">
        <span>مبحث ۵: Tree-of-Thought</span>
        <small>صفحات ۳۲–۳۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-6">
        <span>مبحث ۶: Deliberate Prompting</span>
        <small>صفحات ۳۴–۳۵</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-3"
              data-section="section-3-7">
        <span>مبحث ۷: جمع‌بندی فصل سوم</span>
        <small>مرور</small>
      </button>
    </li>
  </ul>
</li>

        <!-- فصل چهارم -->
<li class="toc-chapter" data-chapter="chapter-4">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل چهارم: تکنیک‌های ساختاردهی خروجی</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>
  <ul class="toc-section-list">
    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-1">
        <span>مبحث ۱: مقدمه – چرا ساختار مهم است؟</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-2">
        <span>مبحث ۲: Specification Prompting</span>
        <small>صفحات ۳۵–۳۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-3">
        <span>مبحث ۳: Format Prompting</span>
        <small>صفحات ۳۸–۴۳</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-4">
        <span>مبحث ۴: Pointwise Prompting</span>
        <small>صفحات ۴۳–۴۶</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-5">
        <span>مبحث ۵: Instruction Hierarchy</span>
        <small>صفحات ۴۶–۴۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-6">
        <span>مبحث ۶: Rewriting Prompts</span>
        <small>صفحات ۴۸–۵۰</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-7">
        <span>مبحث ۷: Multi-turn Formatting</span>
        <small>صفحات ۵۰–۵۲</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
              data-chapter="chapter-4"
              data-section="section-4-8">
        <span>مبحث ۸: جمع‌بندی فصل چهارم</span>
        <small>مرور</small>
      </button>
    </li>
  </ul>
</li>

<!-- فصل پنجم -->
<li class="toc-chapter" data-chapter="chapter-5">
  <div class="toc-chapter-header">
    <div class="toc-chapter-title">فصل پنجم: خطاها، محدودیت‌ها و کنترل کیفیت مدل</div>
    <div class="toc-chapter-toggle">＋</div>
  </div>

  <ul class="toc-section-list">

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-1">
        <span>مبحث ۱: مقدمه – چرا کنترل کیفیت ضروری است؟</span>
        <small>شروع فصل</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-2">
        <span>مبحث ۲: محدودیت‌های مدل</span>
        <small>صفحات ۵۲–۵۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-3">
        <span>مبحث ۳: Hallucination – اطلاعات ساختگی</span>
        <small>صفحات ۵۴–۵۶</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-4">
        <span>مبحث ۴: تکنیک‌های کاهش خطا</span>
        <small>صفحات ۵۶–۶۰</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-5">
        <span>مبحث ۵: Safety و محتوای ممنوع</span>
        <small>صفحات ۶۰–۶۲</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-6">
        <span>مبحث ۶: Verification – راستی‌آزمایی خروجی</span>
        <small>صفحات ۶۲–۶۴</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-7">
        <span>مبحث ۷: Grounding – اتصال به واقعیت</span>
        <small>صفحات ۶۴–۶۶</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-8">
        <span>مبحث ۸: Guardrails – ریل‌های محافظتی</span>
        <small>صفحات ۶۶–۶۷</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-9">
        <span>مبحث ۹: Self-checking – بررسی و اصلاح توسط مدل</span>
        <small>صفحات ۶۷–۶۸</small>
      </button>
    </li>

    <li class="toc-section-item">
      <button class="toc-btn section-btn"
        data-chapter="chapter-5"
        data-section="section-5-10">
        <span>مبحث ۱۰: جمع‌بندی فصل پنجم</span>
        <small>مرور</small>
      </button>
    </li>

  </ul>
</li>

<!-- فصل ششم (مثال) -->
        <li class="toc-chapter" data-chapter="chapter-3">
          <div class="toc-chapter-header">
            <div class="toc-chapter-title">فصل سوم: عنوان فصل سوم</div>
            <div class="toc-chapter-toggle">＋</div>
          </div>
          <ul class="toc-section-list">
            <li class="toc-section-item">
              <button class="toc-btn section-btn"
                      data-chapter="chapter-3"
                      data-section="section-3-1">
                <span>مبحث ۱: عنوان مبحث اول فصل سوم</span>
                <small>…</small>
              </button>
            </li>
          </ul>
        </li>
        
<!-- فصل هفتم (مثال) -->
        <li class="toc-chapter" data-chapter="chapter-3">
          <div class="toc-chapter-header">
            <div class="toc-chapter-title">فصل سوم: عنوان فصل سوم</div>
            <div class="toc-chapter-toggle">＋</div>
          </div>
          <ul class="toc-section-list">
            <li class="toc-section-item">
              <button class="toc-btn section-btn"
                      data-chapter="chapter-3"
                      data-section="section-3-1">
                <span>مبحث ۱: عنوان مبحث اول فصل سوم</span>
                <small>…</small>
              </button>
            </li>
          </ul>
        </li>


<!-- فصل هشتم (مثال) -->
        <li class="toc-chapter" data-chapter="chapter-3">
          <div class="toc-chapter-header">
            <div class="toc-chapter-title">فصل سوم: عنوان فصل سوم</div>
            <div class="toc-chapter-toggle">＋</div>
          </div>
          <ul class="toc-section-list">
            <li class="toc-section-item">
              <button class="toc-btn section-btn"
                      data-chapter="chapter-3"
                      data-section="section-3-1">
                <span>مبحث ۱: عنوان مبحث اول فصل سوم</span>
                <small>…</small>
              </button>
            </li>
          </ul>
        </li>


        <!-- فصل نهم (مثال) -->
        <li class="toc-chapter" data-chapter="chapter-3">
          <div class="toc-chapter-header">
            <div class="toc-chapter-title">فصل سوم: عنوان فصل سوم</div>
            <div class="toc-chapter-toggle">＋</div>
          </div>
          <ul class="toc-section-list">
            <li class="toc-section-item">
              <button class="toc-btn section-btn"
                      data-chapter="chapter-3"
                      data-section="section-3-1">
                <span>مبحث ۱: عنوان مبحث اول فصل سوم</span>
                <small>…</small>
              </button>
            </li>
          </ul>
        </li>
        
      </ul>
    </section>

    <!-- متن فصل‌ها و مبحث‌ها -->
    <section class="chapters">

      <!-- فصل اول -->
<article id="chapter-1" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل اول: پرامپت‌نویسی چیست و مدل چگونه کار می‌کند؟</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-1-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – پرامپت و نقش آن</h3>

      <p>
        وقتی با یک مدل هوش مصنوعی مثل Gemini یا GPT حرف می‌زنی، چیزی که تایپ می‌کنی
        «پرامپت» نام دارد. پرامپت همان نقطهٔ شروع است؛ ورودی‌ای که مدل با آن تصمیم
        می‌گیرد چه متنی تولید کند.
      </p>

      <p>
        نوشتن پرامپت کار سختی نیست؛ اما نوشتن پرامپتی که خروجی دقیق، قابل اعتماد و
        درست بدهد، یک مهارت است.
      </p>

      <p>کیفیت جواب مدل به چند چیز بستگی دارد:</p>

      <ul>
        <li>خود متنِ پرامپت</li>
        <li>لحن و سبک نوشته</li>
        <li>ترتیب اطلاعات</li>
        <li>جزئیات و شفافیت</li>
        <li>مدل انتخاب‌شده</li>
        <li>تنظیمات مدل</li>
      </ul>

      <p>
        اگر پرامپت مبهم باشد، مدل نیز جواب مبهم می‌دهد. اگر پرامپت واضح باشد، مدل
        مسیر درست را پیدا می‌کند.
      </p>

      <p>
        پرامپت‌نویسی یک کار تکرارشونده است؛ تست می‌کنی، اصلاح می‌کنی، بهتر می‌کنی.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        مدل‌ها «معنی» را نمی‌فهمند؛ فقط پیش‌بینی می‌کنند. هر کلمهٔ تو یک چراغ است
        که مسیر پیش‌بینی را روشن می‌کند. اگر چراغ‌ها واضح باشند → مدل عالی پیش
        می‌رود؛ اگر تاریک یا نامرتب باشند → مدل به بیراهه می‌رود.
      </p>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-1-2" class="section">
      <h3 class="section-title">مبحث ۲: مدل‌های زبانی چگونه پاسخ می‌سازند؟</h3>

      <p>
        مدل‌های زبانی مثل Gemini، GPT، Claude و… در اصل ماشین‌های پیش‌بینی متن
        هستند.
      </p>

      <p>کارشان را قدم‌به‌قدم این‌گونه انجام می‌دهند:</p>

      <ol>
        <li>پرامپت تو را می‌گیرند.</li>
        <li>بهترین کلمهٔ بعدی را حدس می‌زنند.</li>
        <li>آن کلمه را به متن اضافه می‌کنند.</li>
        <li>دوباره با توجه به کل متن، کلمهٔ بعدی را حدس می‌زنند.</li>
        <li>و همین‌طور تا پایان خروجی ادامه می‌دهند.</li>
      </ol>

      <p>
        به همین دلیل است که: پرامپت دقیق → خروجی دقیق، پرامپت مبهم → خروجی نامربوط،
        پرامپت طولانی و شلوغ → سردرگمی مدل.
      </p>

      <p>پرامپت خوب یعنی قرار دادن مدل در مسیر درست پیش‌بینی.</p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        این دقیقاً مثل راه رفتن در تاریکی است. تو با کلماتت چراغ‌قوه دست مدل
        می‌دهی. اگر نور کافی بدهی، به مقصد می‌رسد؛ اگر نور کم باشد، فقط حدس می‌زند
        و اشتباه می‌کند.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-1-3" class="section">
      <h3 class="section-title">مبحث ۳: پرامپت‌نویسی یعنی طراحی یک مسیر واضح</h3>

      <p>Prompt Engineering یعنی:</p>

      <ul>
        <li>مشخص کردن هدف</li>
        <li>ساده کردن درخواست</li>
        <li>جلوگیری از حدس‌های غیرضروری</li>
        <li>کم‌کردن ابهام</li>
        <li>اضافه کردن مثال در صورت نیاز</li>
      </ul>

      <p>هدف این است که مدل حدس‌های درست بزند، نه حدس‌های تصادفی.</p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-1-4" class="section">
      <h3 class="section-title">مبحث ۴: تنظیمات مدل و کنترل خروجی</h3>

      <p>
        این بخش یکی از مهم‌ترین قسمت‌هاست. علاوه بر خود پرامپت، تنظیمات مدل تعیین
        می‌کنند مدل چطور جواب بدهد.
      </p>

      <p>تنظیمات اصلی عبارتند از:</p>

      <ol>
        <li>تعداد توکن خروجی (Max Output Tokens)</li>
        <li>Temperature (دما)</li>
        <li>Top-K</li>
        <li>Top-P (Nucleus Sampling)</li>
      </ol>

      <h4>⭐ ۱) تعداد توکن خروجی</h4>
      <p>
        این گزینه فقط تعیین می‌کند مدل چقدر متن تولید کند. اگر مقدارش کم باشد →
        مدل وسط جمله متوقف می‌شود. اگر زیاد باشد → مدل فرصت کامل‌کردن پاسخ را دارد.
      </p>
      <p>
        کم بودن عدد به معنی خلاصه‌نویسی نیست؛ بلکه یعنی خروجی زورکی قطع شده است.
      </p>

      <h4>⭐ ۲) Temperature (دما)</h4>
      <p>
        Temperature تعیین می‌کند مدل چقدر «خلاق» یا «دقیق» باشد. دمای پایین →
        خروجی دقیق‌تر، منطقی‌تر و قابل‌پیش‌بینی‌تر. دمای بالا → خروجی خلاقانه‌تر،
        متنوع‌تر و غیرمنتظره‌تر.
      </p>
      <p>Temperature = 0 یعنی مدل همیشه «مطمئن‌ترین» کلمه را انتخاب می‌کند.</p>

      <h4>🔵 این تنظیمات کجا قابل تغییرند؟</h4>
      <p>
        در برنامه‌های چت معمولی مثل اپلیکیشن Gemini، سایت ChatGPT و ربات‌های آماده،
        این تنظیمات (Temperature، Top-P، Top-K) در دسترس کاربر عادی نیستند. سیستم
        خودش برای استفاده عمومی تنظیمات را انتخاب می‌کند.
      </p>

      <p>این تنظیمات فقط در سه حالت قابل تغییر هستند:</p>

      <h4>۱) Vertex AI Studio (گوگل کلود)</h4>
      <p>
        محیطی حرفه‌ای که کتاب هم بر اساس آن نوشته شده است. این‌جا می‌توانی
        Temperature، Top-K، Top-P و Max Tokens را دقیق تنظیم کنی.
      </p>

      <h4>۲) استفاده از API (برای ساخت ربات یا اپلیکیشن)</h4>
      <p>
        اگر مثل پروژهٔ Tavita یک ربات می‌سازی، تمام این تنظیمات را درون کد کنترل
        می‌کنی.
      </p>

<pre><code>model.generate(
    prompt="...",
    temperature=0.3,
    top_p=0.95,
    top_k=40,
    max_output_tokens=300
)
</code></pre>

      <h4>۳) ربات‌های سفارشی (مثل ربات ایتا / Tavita Bot)</h4>
      <p>
        در این حالت کاربر تنظیمات را نمی‌بیند، اما تو (توسعه‌دهنده) تعیین می‌کنی
        مدل چطور رفتار کند:
      </p>

      <ul>
        <li>Temperature = 0 → ربات دقیق و خشک</li>
        <li>Temperature ≈ 0.5 → ربات متعادل و روان</li>
        <li>Temperature ≈ 0.9 → ربات خلاق و آزاد</li>
      </ul>

      <h4>🔵 جمع‌بندی طاویتا درباره دسترسی به تنظیمات</h4>
      <ul>
        <li>در چت‌های معمولی → ❌ تنظیمات وجود ندارند.</li>
        <li>در Google Vertex AI Studio → ✔️ کامل در دسترس‌اند.</li>
        <li>در API و ربات شخصی → ✔️ قابل کنترل توسط برنامه‌نویس.</li>
      </ul>
      <p>این بخش را کتاب توضیح نداده بود؛ طاویتا آن را تکمیل کرد.</p>

      <h4>⭐ ۳) Top-K</h4>
      <p>
        Top-K انتخاب مدل را محدود می‌کند به K کلمهٔ محتمل‌تر. K پایین → خروجی دقیق
        و قابل‌پیش‌بینی. K بالا → خروجی متنوع‌تر.
      </p>
      <p>Top-K = 1 یعنی فقط بهترین حدس.</p>

      <h4>⭐ ۴) Top-P (Nucleus Sampling)</h4>
      <p>
        Top-P تعیین می‌کند مدل از بین کلماتی انتخاب کند که مجموع احتمالشان به P
        می‌رسد. P پایین → خروجی محدودتر؛ P بالا → خروجی آزادتر و خلاق‌تر.
      </p>

      <h4>🔵 توضیح طاویتا درباره Top-K و Top-P</h4>
      <p>
        Top-K مثل این است که بگویی: «فقط از بین ۵ انتخاب اولت یک‌دانه بردار.»  
        Top-P یعنی: «از بین انتخاب‌هایی که با هم مثلاً ۹۰٪ مطمئنی، یکی را انتخاب
        کن.»
      </p>
      <p>Top-K عدد محور است؛ Top-P احتمال‌محور است.</p>

      <h4>⭐ بهترین تنظیمات پیشنهادی کتاب</h4>
      <ul>
        <li>متن منظم + کمی خلاقیت: Temperature = 0.2 ، Top-P = 0.95 ، Top-K = 30</li>
        <li>متن بسیار خلاق و هنری: Temperature = 0.9 ، Top-P = 0.99 ، Top-K = 40</li>
        <li>کارهای علمی و قطعی: Temperature = 0</li>
      </ul>

      <h4>⭐ مشکل «لوپ تکرار»</h4>
      <p>
        اگر تنظیمات درست نباشند، مدل ممکن است کلمات را تکرار کند، گیر کند یا خروجی
        نامربوط تولید کند. این مشکل با تنظیم درست Temperature و Top-P تا حد زیادی
        برطرف می‌شود.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-1-5" class="section">
      <h3 class="section-title">مبحث ۵: جمع‌بندی فصل اول</h3>

      <ul>
        <li>مدل‌ها می‌نویسند چون پیش‌بینی می‌کنند.</li>
        <li>پرامپت خوب یعنی هدایت درست این پیش‌بینی.</li>
        <li>تنظیمات مدل، شدت خلاقیت، دقت و طول خروجی را کنترل می‌کند.</li>
        <li>برای کاربر معمولی این تنظیمات در دسترس نیست.</li>
        <li>فقط توسعه‌دهندگان می‌توانند آن‌ها را کنترل کنند.</li>
        <li>پرامپت‌نویسی یک مهارت هنری–فنی است.</li>
      </ul>
    </section>

  </div>
</article>

      <!-- فصل دوم -->
<article id="chapter-2" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل دوم: تکنیک‌های پرامپت‌نویسی (Prompting Techniques)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-2-1" class="section">
      <h3 class="section-title">مبحث ۱: Zero-shot Prompting</h3>

      <p>
        Zero-shot یعنی هیچ مثالی نمی‌دهی؛ فقط دستور را می‌نویسی. مدل براساس دانش
        قبلی‌اش تصمیم می‌گیرد.
      </p>

      <p>مثال:</p>
      <p><strong>«این متن را مثبت، منفی یا خنثی طبقه‌بندی کن.»</strong></p>

      <p>کجا استفاده می‌شود؟</p>
      <ul>
        <li>وقتی کار ساده است</li>
        <li>وقتی مدل دانش اولیه دارد</li>
        <li>وقتی نمی‌خواهی پرامپت طولانی شود</li>
      </ul>

      <p>
        اما همیشه دقیق نیست؛ چون مدل ممکن است سبک دلخواه تو را حدس نزند.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Zero-shot مثل این است که بگویی: «برو چای خوب درست کن» بدون اینکه بگویی
        چای پررنگ؟ کم‌رنگ؟ شیرین؟ اینجاست که خروجی ممکن است مطابق سلیقه‌ات نباشد.
      </p>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-2-2" class="section">
      <h3 class="section-title">مبحث ۲: One-shot & Few-shot Prompting</h3>

      <p>
        One-shot یعنی یک مثال می‌دهی و مدل را در مسیر قرار می‌دهی. Few-shot یعنی
        چند مثال (معمولاً ۳ تا ۵) می‌دهی تا مدل الگو را کامل یاد بگیرد.
      </p>

      <p>مزیت‌ها:</p>
      <ul>
        <li>مدل دقیقاً می‌فهمد چه خروجی می‌خواهی</li>
        <li>لحن، سبک و ساختار از مثال‌ها یاد گرفته می‌شود</li>
        <li>احتمال خطا بسیار کم می‌شود</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Few-shot یعنی تو داری «قانون تولید خروجی» را به مدل یاد می‌دهی.  
        اگر مثال‌ها JSON باشند → مدل هم JSON می‌نویسد.  
        اگر مثال‌ها خیلی خلاصه باشند → خروجی هم خلاصه می‌شود.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-2-3" class="section">
      <h3 class="section-title">مبحث ۳: System Prompting (پرامپت سیستمی)</h3>

      <p>
        System prompt تعریف «وظیفه اصلی مدل» است. مثل اینکه بگویی:
      </p>

      <ul>
        <li>«تو یک مترجم حرفه‌ای هستی.»</li>
        <li>«فقط خروجی JSON بده.»</li>
        <li>«همیشه علمی و دقیق بنویس.»</li>
      </ul>

      <p>
        این دستور در ابتدای پرامپت می‌آید و رفتار کلی مدل را ثابت نگه می‌دارد.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        System prompt مثل این است که به مدل بگویی:  
        «این نقش توست، خارج نشو.»  
        اگر بگویی «تو یک متخصص امنیت سایبری هستی»، مدل همه‌چیز را از دید امنیتی
        می‌نویسد.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-2-4" class="section">
      <h3 class="section-title">مبحث ۴: Role Prompting (تعیین نقش)</h3>

      <p>
        در Role Prompting به مدل می‌گویی شبیه چه شخصیتی رفتار کند:
      </p>

      <ul>
        <li>«مثل یک نویسنده طنز صحبت کن.»</li>
        <li>«مثل یک پزشک عمومی توضیح بده.»</li>
        <li>«مثل یک مربی انگیزشی حرف بزن.»</li>
      </ul>

      <p>
        این روش برای کنترل لحن، احساس و سبک نوشتن مدل فوق‌العاده است.
      </p>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        Role Prompting مثل این است که یک «ماسک شخصیتی» روی مدل بگذاری.  
        حتی جواب‌های فنی هم می‌توانند شاعرانه، طنزآلود یا کودکانه شوند.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-2-5" class="section">
      <h3 class="section-title">مبحث ۵: Contextual Prompting (پرامپت با زمینه)</h3>

      <p>
        Context یعنی دادن اطلاعات پس‌زمینه‌ای تا مدل دقیق بفهمد در چه شرایطی هستی:
      </p>

      <ul>
        <li>«این متن مربوط به وبلاگ بازی‌های دهه ۸۰ است…»</li>
        <li>«در ادامهٔ گفت‌وگوی قبلی…»</li>
        <li>«اطلاعات اولیهٔ پروژه: …»</li>
      </ul>

      <p>با Context پاسخ‌ها دقیق‌تر و مرتبط‌تر می‌شوند.</p>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        Context مثل دادن “پس‌زمینه ذهنی” به مدل است.  
        اگر فقط بپرسی «سه موضوع مقاله بده» هر چیزی ممکن است بدهد.  
        اما اگر بگویی:  
        «در زمینهٔ بازی‌های کلاسیک دهه ۸۰، سه موضوع مقاله بده.»  
        مدل دقیقاً هدف‌مند می‌شود.
      </p>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-2-6" class="section">
      <h3 class="section-title">مبحث ۶: جمع‌بندی فصل دوم</h3>

      <ul>
        <li>Zero-shot → سریع، ساده، اما نه‌چندان دقیق</li>
        <li>One-shot & Few-shot → بهترین روش برای خروجی باثبات</li>
        <li>System Prompt → تعیین چارچوب و رفتار کلی مدل</li>
        <li>Role Prompt → تعیین لحن، شخصیت و سبک پاسخ</li>
        <li>Contextual Prompt → دقیق‌ترین و هدفمندترین روش</li>
      </ul>

      <p>پرامپت خوب یعنی طراحی هوشمندانه مسیر ذهنی مدل.</p>
    </section>

  </div>
</article>

      <!-- فصل سوم -->
<article id="chapter-3" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل سوم: تکنیک‌های استدلال و تولید پاسخ هوشمند (Reasoning Prompts)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-3-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – چرا به استدلال نیاز داریم؟</h3>

      <p>
        فصل سوم دربارهٔ تکنیک‌هایی است که مدل را مجبور می‌کنند عمیق‌تر فکر کند.
        این تکنیک‌ها وقتی لازم‌اند که:
      </p>

      <ul>
        <li>کار پیچیده باشد</li>
        <li>نیاز به تحلیل داشته باشی</li>
        <li>چند مرحله پردازش لازم باشد</li>
        <li>مدل نباید جواب سطحی بدهد</li>
        <li>باید چند گزینه را مقایسه کند</li>
      </ul>

      <p>تکنیک‌های این فصل عبارت‌اند از:</p>
      <ol>
        <li>Step-back prompting</li>
        <li>Chain-of-Thought prompting</li>
        <li>Self-consistency reasoning</li>
        <li>Tree of Thought</li>
        <li>Deliberate prompting</li>
      </ol>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-3-2" class="section">
      <h3 class="section-title">مبحث ۲: Step-back Prompting</h3>

      <p>
        در Step-back Prompting، قبل از اینکه مدل پاسخ بدهد، از او می‌خواهی یک قدم
        عقب‌تر برود و ابتدا مسئله را در سطحی کلی توضیح دهد.
      </p>

      <p>نمونهٔ ساده:</p>
      <blockquote>
        قبل از پاسخ، یک پاراگراف دربارهٔ این‌که مسئله چه نوع چالشی است بنویس، سپس
        جواب نهایی را بده.
      </blockquote>

      <p>این تکنیک باعث می‌شود مدل:</p>
      <ul>
        <li>موضوع را بهتر دسته‌بندی کند</li>
        <li>دید کلی پیدا کند</li>
        <li>از اشتباهات سریع جلوگیری کند</li>
        <li>از حالت «حدس‌زدن سریع» خارج شود</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Step-back مثل این است که قبل از حل مسئله بگویی:  
        «صبر کن… اول بگو این سؤال در چه دسته‌ای است؟ علمی، منطقی، احساسی یا تحلیلی؟»
      </p>
      <p>
        وقتی مدل این قدم را برمی‌دارد، کمتر اشتباهات بچگانه می‌کند و پاسخ‌ها
        انسانی‌تر و حرفه‌ای‌تر می‌شوند.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-3-3" class="section">
      <h3 class="section-title">مبحث ۳: Chain-of-Thought (زنجیرهٔ تفکر)</h3>

      <p>
        Chain-of-Thought یکی از معروف‌ترین تکنیک‌های دنیاست. یعنی از مدل می‌خواهی
        قبل از جواب نهایی، مرحله‌به‌مرحله فکرش را بنویسد.
      </p>

      <p>مثال:</p>
      <blockquote>
        مرحله‌به‌مرحله استدلال کن و سپس پاسخ نهایی را بده.
      </blockquote>

      <p>مزایا:</p>
      <ul>
        <li>مدل کمتر اشتباه می‌کند.</li>
        <li>جواب‌ها منطقی‌تر و قابل‌استنادتر می‌شوند.</li>
        <li>در ریاضی، تحلیل، پژوهش و تصمیم‌گیری بهتر عمل می‌کند.</li>
        <li>در پرسش‌های چندمرحله‌ای عالی است.</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Chain-of-Thought مدل را از حالت «حدس سریع» به حالت «تفکر مرحله‌دار» می‌برد.
        وقتی مدل مجبور شود مراحلش را بنویسد، نمی‌تواند الکی نتیجه‌گیری کند.
      </p>
      <p>
        برای کارهای تحقیقاتی، دانشجویی، تحلیل داده، پژوهش، حل مسئله، منطق و
        برنامه‌ریزی این تکنیک تقریباً ضروری است.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-3-4" class="section">
      <h3 class="section-title">مبحث ۴: Self-consistency reasoning</h3>

      <p>
        Self-consistency یعنی:
      </p>
      <ol>
        <li>چند Chain-of-Thought مختلف از مدل می‌گیری.</li>
        <li>مدل چند مسیر فکری متفاوت ایجاد می‌کند.</li>
        <li>در پایان از او می‌خواهی سازگارترین و منطقی‌ترین مسیر را انتخاب کند.</li>
      </ol>

      <p>
        این روش دقت را بالا می‌برد؛ چون مدل از بین چند راه‌حل، بهترین را انتخاب
        می‌کند.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Self-consistency مثل این است که بگویی:  
        «چند راه‌حل بده، بعد خودت منطقی‌ترین را انتخاب کن.»
      </p>
      <p>
        برای مسائل سخت، متون پژوهشی و تحلیل‌های چندلایه فوق‌العاده کاربردی است.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-3-5" class="section">
      <h3 class="section-title">مبحث ۵: Tree-of-Thought (درخت تفکر)</h3>

      <p>
        Tree-of-Thought یکی از پیشرفته‌ترین تکنیک‌هاست. در این روش، مدل به‌جای یک
        مسیر خطی، چند مسیر فکری را مثل شاخه‌های یک درخت می‌سازد.
      </p>

      <p>در Tree-of-Thought معمولاً:</p>
      <ul>
        <li>چند ایدهٔ مختلف تولید می‌شود.</li>
        <li>هر ایده کمی گسترش داده می‌شود.</li>
        <li>ایده‌ها با هم مقایسه می‌شوند.</li>
        <li>بهترین شاخهٔ فکری انتخاب می‌شود.</li>
        <li>در نهایت، جواب نهایی از روی آن شاخه ساخته می‌شود.</li>
      </ul>

      <p>
        این روش برای بازی‌های ذهنی، استراتژی، حل مسئله‌های باز و ایده‌پردازی
        عالی است.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Tree-of-Thought مثل این است که بگویی:  
        «چند مسیر فکری مختلف رسم کن، بعد بهترینشان را انتخاب کن.»
      </p>
      <p>
        در برنامه‌ریزی بلندمدت، تصمیم‌گیری پیچیده، تحلیل سناریو و طراحی استراتژی،
        این روش به مدل قدرت یک مشاور حرفه‌ای می‌دهد.
      </p>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-3-6" class="section">
      <h3 class="section-title">مبحث ۶: Deliberate Prompting</h3>

      <p>
        Deliberate Prompting یعنی از مدل بخواهی «آهسته‌تر، عمیق‌تر و هدفمندتر»
        فکر کند.
      </p>

      <p>مثال:</p>
      <blockquote>
        قبل از پاسخ نهایی، با دقت فکر کن و در چند مرحله توضیح بده چگونه به نتیجه
        رسیدی.
      </blockquote>

      <p>این یک نسخهٔ ارتقایافته از Chain-of-Thought است و برای کارهای جدی و دقیق است.</p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Deliberate Prompting برای زمانی است که:
      </p>
      <ul>
        <li>نمی‌خواهی مدل جواب عجولانه بدهد.</li>
        <li>مسئله پیچیده است.</li>
        <li>دقت خیلی مهم است.</li>
        <li>خروجی باید توجیه منطقی داشته باشد.</li>
      </ul>

      <p>
        انگار به مدل می‌گویی: «عجله نکن. آرام و عمیق فکر کن. قدم‌به‌قدم جلو بیا،
        بعد نتیجه بده.» و واقعاً گاهی معجزه می‌کند.
      </p>
    </section>

    <!-- مبحث ۷ -->
    <section id="section-3-7" class="section">
      <h3 class="section-title">مبحث ۷: جمع‌بندی فصل سوم</h3>

      <ul>
        <li>Step-back → به مدل دید کلی بده و از اشتباهات ساده جلوگیری کن.</li>
        <li>Chain-of-Thought → مدل را مجبور کن مرحله‌به‌مرحله فکر کند.</li>
        <li>Self-consistency → چند مسیر فکری بگیر و بهترین را انتخاب کن.</li>
        <li>Tree-of-Thought → شاخه‌های مختلف فکر بساز و مقایسه کن.</li>
        <li>Deliberate Prompting → به مدل بگو آهسته، دقیق و مسئولانه فکر کند.</li>
      </ul>

      <p>
        این تکنیک‌ها، هوش مصنوعی را از یک «ماشین جواب سریع» به یک «همکار
        فکری و تحلیلی» تبدیل می‌کنند.
      </p>
    </section>

  </div>
</article>

<!-- فصل چهارم -->
<article id="chapter-4" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل چهارم: تکنیک‌های ساختاردهی خروجی (Structuring Responses)</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱: مقدمه -->
    <section id="section-4-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – چرا ساختاردهی خروجی مهم است؟</h3>

      <p>
        این فصل به تو یاد می‌دهد چطور کاری کنی که مدل:
      </p>
      <ul>
        <li>مرتب جواب بدهد،</li>
        <li>ساختارمند بنویسد،</li>
        <li>در یک قالب مشخص خروجی تولید کند،</li>
        <li>و از حدس و گمان بی‌مورد دوری کند.</li>
      </ul>

      <p>در این فصل با شش تکنیک مهم آشنا می‌شوی:</p>
      <ol>
        <li>Specification prompting (مشخصات دقیق خروجی)</li>
        <li>Format prompting (قالب‌بندی: JSON، Markdown، جدول و…)</li>
        <li>Pointwise prompting (پرسش‌گام‌به‌گام)</li>
        <li>Instruction hierarchy (سلسله‌مراتب دستورات)</li>
        <li>Rewriting prompts (بازنویسی بر اساس الگو)</li>
        <li>Multi-turn formatting (ساختاردهی در چند پیام)</li>
      </ol>
    </section>

    <!-- مبحث ۲: Specification -->
    <section id="section-4-2" class="section">
      <h3 class="section-title">مبحث ۲: Specification Prompting</h3>

      <p>
        Specification یعنی خیلی دقیق بنویسی که چه خروجی می‌خواهی. اگر فقط بگویی:
        «این متن را خلاصه کن»، خروجی می‌تواند یک جمله باشد یا یک پاراگراف طولانی.
      </p>

      <p>اما اگر بگویی:</p>
      <blockquote>
        این متن را در ۳ نکتهٔ اصلی، هر نکته حداکثر ۱۲ کلمه، با لحن رسمی خلاصه کن.
      </blockquote>

      <p>مدل دقیقاً مطابق همین مشخصات جواب می‌دهد.</p>

      <p><strong>Specification = کاهش ابهام + افزایش دقت.</strong></p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        مشخصات دقیق یعنی به مدل بگویی:
      </p>
      <ul>
        <li>مقدار خروجی چقدر باشد،</li>
        <li>چند بخش داشته باشد،</li>
        <li>لحن رسمی، دوستانه یا تخصصی باشد،</li>
        <li>محدودیت کلمه و جمله چیست،</li>
        <li>چه چیزهایی ممنوع است.</li>
      </ul>

      <p>هرچه تو دقیق‌تر باشی، مدل بهتر می‌درخشد.</p>
    </section>

    <!-- مبحث ۳: Format Prompting -->
    <section id="section-4-3" class="section">
      <h3 class="section-title">مبحث ۳: Format Prompting</h3>

      <p>
        Format Prompting یعنی خروجی را مجبور کنی در قالب مشخصی قرار بگیرد؛ مثلاً:
      </p>
      <ul>
        <li>JSON</li>
        <li>جدول</li>
        <li>لیست شماره‌دار</li>
        <li>Markdown</li>
        <li>HTML</li>
        <li>CSV</li>
        <li>پاراگراف با طول مشخص</li>
        <li>قالب پرسش و پاسخ</li>
      </ul>

      <p>مثال:</p>
      <blockquote>
        خروجی را فقط در قالب JSON استاندارد بده. هیچ توضیح اضافی ننویس.
      </blockquote>

      <p>یا:</p>
      <blockquote>
        نتیجه را در یک جدول ۳ ستونه بده: مفهوم | توضیح | مثال.
      </blockquote>

      <p>
        این تکنیک برای برنامه‌نویسی، ساخت ربات و استفاده از خروجی در سیستم‌های
        دیگر فوق‌العاده است.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        فرمت مشخص، مدل را از حاشیه رفتن و حرف‌های اضافی نجات می‌دهد. وقتی می‌گویی
        «فقط JSON»، مدل وسط آن شعر یا داستان نمی‌آورد و خروجی تمیز، قابل‌استفاده و
        استاندارد تحویل می‌دهد.
      </p>
      <p>
        اگر می‌خواهی خروجی را وارد برنامه، دیتابیس، UI یا هر سیستم دیگری کنی،
        فرمت‌دادن اجباری است.
      </p>
    </section>

    <!-- مبحث ۴: Pointwise -->
    <section id="section-4-4" class="section">
      <h3 class="section-title">مبحث ۴: Pointwise Prompting</h3>

      <p>
        Pointwise یعنی کار را نقطه‌به‌نقطه و بخش‌به‌بخش به مدل بدهی، نه یک‌باره.
      </p>

      <p>به‌جای اینکه بگویی:</p>
      <blockquote>
        یک مقالهٔ کامل بنویس.
      </blockquote>

      <p>این‌گونه می‌گویی:</p>
      <ol>
        <li>اول یک عنوان پیشنهادی بده.</li>
        <li>بعد یک مقدمه در دو پاراگراف بنویس.</li>
        <li>سپس بخش اصلی را در ۴ تیتر با توضیح کوتاه بنویس.</li>
        <li>در آخر یک جمع‌بندی یک پاراگرافی بده.</li>
      </ol>

      <p>
        این روش اجازه می‌دهد خروجی مرحله‌دار، تحت کنترل و با کیفیت بهتر تولید شود.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Pointwise یکی از بهترین روش‌ها برای تولید محتواست. وقتی وظیفه را به چند
        مرحله تقسیم می‌کنی، مدل کمتر اشتباه می‌کند و می‌توانی در هر مرحله اصلاح و
        هدایت کنی.
      </p>
      <p>
        در پروژه‌نویسی، مقاله‌نویسی، برنامه‌نویسی، سناریونویسی و ربات‌های آموزشی
        فوق‌العاده کاربرد دارد.
      </p>
    </section>

    <!-- مبحث ۵: Instruction Hierarchy -->
    <section id="section-4-5" class="section">
      <h3 class="section-title">مبحث ۵: Instruction Hierarchy (سلسله‌مراتب دستورات)</h3>

      <p>
        Instruction Hierarchy یعنی دستورات را از مهم‌ترین تا جزئی‌ترین مرتب کنی تا
        مدل بداند کدام قانون، اولویت دارد.
      </p>

      <p>مثال:</p>
      <ol>
        <li>قانون اصلی: فقط خروجی در قالب JSON بده.</li>
        <li>قانون دوم: هیچ متن اضافی ننویس.</li>
        <li>قانون سوم: پاسخ‌ها کوتاه باشند.</li>
        <li>قانون چهارم: لحن رسمی باشد.</li>
      </ol>

      <p>
        وقتی مدل بداند کدام دستور مهم‌تر است، در موقع تضاد، از قانون اصلی پیروی
        می‌کند.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        گاهی خودت ناخواسته در پرامپت تناقض ایجاد می‌کنی؛ مثلاً هم می‌گویی «کامل
        توضیح بده» و هم «کوتاه بنویس»! در این حالت، مدل نمی‌داند کدام را جدی‌تر
        بگیرد.
      </p>
      <p>
        با تعریف سلسله‌مراتب، به مدل می‌گویی: «این قانون از همه مهم‌تر است، بعد
        این، بعد این…» و به این ترتیب خروجی منظم و بدون تناقض می‌گیری.
      </p>
    </section>

    <!-- مبحث ۶: Rewriting -->
    <section id="section-4-6" class="section">
      <h3 class="section-title">مبحث ۶: Rewriting Prompts (بازنویسی بر اساس الگو)</h3>

      <p>
        در Rewriting از مدل می‌خواهی یک متن را بر اساس یک نمونهٔ مشخص بازنویسی
        کند.
      </p>

      <p>مثال:</p>
      <blockquote>
        این متن را دقیقاً با همین سبک نگارش نمونهٔ زیر بازنویسی کن:  
        [نمونهٔ متن]  
        حالا متن جدید را بازنویسی کن.
      </blockquote>

      <p>این روش برای این کارها عالی است:</p>
      <ul>
        <li>تقلید لحن،</li>
        <li>تقلید قالب نوشتاری،</li>
        <li>برندسازی،</li>
        <li>استانداردسازی محتوا،</li>
        <li>ایجاد یک امضای نوشتاری ثابت.</li>
      </ul>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        در این تکنیک، مدل از «الگوی رفتاری متن نمونه» یاد می‌گیرد؛ اگر نمونه رسمی
        باشد → خروجی رسمی می‌شود، اگر صمیمی باشد → خروجی صمیمی می‌شود، اگر طنز،
        شاعرانه یا آموزشی باشد → خروجی هم همان‌طور خواهد بود.
      </p>
      <p>
        برای ساخت لحن ثابت یک برند (مثلاً لحن خود طاویتا) این تکنیک فوق‌العاده
        است.
      </p>
    </section>

    <!-- مبحث ۷: Multi-turn Formatting -->
    <section id="section-4-7" class="section">
      <h3 class="section-title">مبحث ۷: Multi-turn Formatting</h3>

      <p>
        Multi-turn Formatting یعنی ساختاردهی خروجی در چند پیام پیاپی؛ به‌جای اینکه
        یک‌باره همه‌چیز را بگیری، مدل را مرحله‌به‌مرحله راهنمایی می‌کنی.
      </p>

      <p>مثلاً:</p>
      <ol>
        <li>اول بگو: «فقط قالب را بساز، هنوز محتوا تولید نکن.»</li>
        <li>بعد: «حالا بخش عنوان را پر کن.»</li>
        <li>بعد: «بخش مقدمه را پر کن.»</li>
        <li>سپس: «بخش نکات کلیدی را اضافه کن.»</li>
      </ol>

      <p>
        این روش باعث می‌شود خروجی تمیز، قابل‌مدیریت و باکیفیت شود و آشفتگی
        ایجاد نشود.
      </p>

      <h4>🔵 توضیح تکمیلی طاویتا</h4>
      <p>
        Multi-turn یعنی محتوا را مثل یک پروژهٔ واقعی، مرحله‌به‌مرحله پیش ببری.
        به‌جای یک پاسخ بزرگ و شاید شلخته، چند خروجی کوچک و استاندارد می‌گیری.
      </p>
      <p>
        این روش برای کارهای سنگین مثل ساخت کتاب، دورهٔ آموزشی، پروژه‌های بزرگ،
        طراحی UI و تولید اسناد کامل، بهترین گزینه است.
      </p>
    </section>

    <!-- مبحث ۸: جمع‌بندی -->
    <section id="section-4-8" class="section">
      <h3 class="section-title">مبحث ۸: جمع‌بندی فصل چهارم</h3>

      <ul>
        <li><strong>Specification:</strong> دقیق بگو چه خروجی می‌خواهی.</li>
        <li><strong>Format prompting:</strong> خروجی را مجبور کن در قالب خاصی باشد.</li>
        <li><strong>Pointwise:</strong> وظیفه را مرحله‌دار کن.</li>
        <li><strong>Instruction hierarchy:</strong> اهمیت دستورات را مشخص کن.</li>
        <li><strong>Rewriting:</strong> متن جدید را مطابق یک نمونه بازنویسی کن.</li>
        <li><strong>Multi-turn:</strong> خروجی سنگین را در چند مرحله بساز.</li>
      </ul>

      <p>
        با این تکنیک‌ها، هوش مصنوعی فقط «جواب‌دهنده» نیست؛ تبدیل می‌شود به ابزاری
        که خروجی تمیز، حرفه‌ای و قابل‌استفاده در دنیای واقعی تولید می‌کند.
      </p>
    </section>

  </div>
</article>


<!-- فصل پنجم -->
<article id="chapter-5" class="chapter">
  <div class="chapter-header">
    <h2 class="chapter-title">فصل پنجم: خطاها، محدودیت‌ها، کنترل کیفیت و بهبود دقت مدل‌ها</h2>
    <div class="chapter-toggle">＋</div>
  </div>

  <div class="chapter-body">

    <!-- مبحث ۱ -->
    <section id="section-5-1" class="section">
      <h3 class="section-title">مبحث ۱: مقدمه – چرا کنترل کیفیت ضروری است؟</h3>

      <p>
        این فصل یاد می‌دهد چگونه کاری کنیم که مدل کمتر اشتباه کند، کمتر اطلاعات ساختگی
        بسازد، از موضوع خارج نشود و خروجی قابل اعتماد تولید کند. این فصل برای پژوهش،
        محصول‌سازی، ربات‌سازی و تحلیل داده حیاتی است.
      </p>

      <ul>
        <li>شناخت محدودیت‌ها</li>
        <li>شناخت هذیان یا Hallucination</li>
        <li>کاهش خطا</li>
        <li>مدیریت محتوای حساس (Safety)</li>
        <li>راستی‌آزمایی خروجی</li>
        <li>اتصال به داده واقعی (Grounding)</li>
        <li>رعایت Guardrails</li>
        <li>Self-checking توسط خود مدل</li>
      </ul>
    </section>

    <!-- مبحث ۲ -->
    <section id="section-5-2" class="section">
      <h3 class="section-title">مبحث ۲: محدودیت‌های مدل</h3>

      <p>مدل‌های زبانی محدودیت‌هایی دارند:</p>

      <ul>
        <li>دانش‌شان محدود به دادهٔ آموزشی است.</li>
        <li>حقیقت را «نمی‌دانند»؛ فقط پیش‌بینی می‌کنند.</li>
        <li>ممکن است اطلاعات غلط تولید کنند.</li>
        <li>ممکن است با اعتمادبه‌نفس غلط صحبت کنند.</li>
        <li>ممکن است چیز غلط را منطقی جلوه دهند.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        مدل «دانشمند» نیست؛ «حدس‌زن ماهر» است. لحنش فقط وانمود می‌کند که مطمئن است.
      </p>
    </section>

    <!-- مبحث ۳ -->
    <section id="section-5-3" class="section">
      <h3 class="section-title">مبحث ۳: Hallucination – اطلاعات ساختگی</h3>

      <p>Hallucination یعنی:</p>

      <ul>
        <li>اطلاعات ساختگی اما طبیعی‌به‌نظر تولید کند.</li>
        <li>ارجاع ساختگی بسازد.</li>
        <li>آمار جعلی بدهد.</li>
        <li>تاریخ یا واقعه‌ای بسازد.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        وقتی مدل جواب دقیق ندارد، به‌جای «نمی‌دانم» چیزی می‌سازد که منطقی به‌نظر برسد.
      </p>
    </section>

    <!-- مبحث ۴ -->
    <section id="section-5-4" class="section">
      <h3 class="section-title">مبحث ۴: تکنیک‌های کاهش خطا</h3>

      <ul>
        <li><strong>۱) Chain-of-Thought:</strong> درخواست استدلال مرحله‌به‌مرحله.</li>
        <li><strong>۲) محدودیت‌های دقیق:</strong> مثل «اگر مطمئن نیستی بگو نمی‌دانم».</li>
        <li><strong>۳) اجبار به منبع (Force citation):</strong> مدل را مجبور کن سند بدهد.</li>
        <li><strong>۴) Grounding:</strong> اتصال به دیتابیس یا API.</li>
        <li><strong>۵) Temperature پایین:</strong> حدس کمتر → خطای کمتر.</li>
        <li><strong>۶) Self-check:</strong> درخواست بازبینی و اصلاح.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        با جمله «جوابت را بررسی کن»، مدل وارد حالت ارزیابی می‌شود و خودش اشتباهات را اصلاح می‌کند.
      </p>
    </section>

    <!-- مبحث ۵ -->
    <section id="section-5-5" class="section">
      <h3 class="section-title">مبحث ۵: Safety و محتوای ممنوع</h3>

      <p>مدل‌ها برای جلوگیری از سوءاستفاده محدودیت دارند:</p>

      <ul>
        <li>محتوای خطرناک</li>
        <li>نفرت‌پراکنی</li>
        <li>افشای اطلاعات خصوصی</li>
        <li>خشونت</li>
        <li>سوگیری‌های حساس</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        در ربات‌سازی، Safety یعنی تعیین اینکه مدل چه چیزهایی را «نباید» تولید کند.
      </p>
    </section>

    <!-- مبحث ۶ -->
    <section id="section-5-6" class="section">
      <h3 class="section-title">مبحث ۶: Verification – راستی‌آزمایی خروجی</h3>

      <p>
        در Verification از مدل می‌خواهی:
      </p>

      <ul>
        <li>خروجی خودش را ارزیابی کند.</li>
        <li>سه دلیل برای احتمال اشتباه بیاورد.</li>
        <li>نسخهٔ اصلاح‌شده ارائه دهد.</li>
      </ul>

      <blockquote>
        «این پاسخ را بررسی کن. اگر غلط است، نسخهٔ درست را بده.»
      </blockquote>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        مدل در حالت Verification دقیق‌تر، محتاط‌تر و تحلیل‌گرتر رفتار می‌کند.
      </p>
    </section>

    <!-- مبحث ۷ -->
    <section id="section-5-7" class="section">
      <h3 class="section-title">مبحث ۷: Grounding – اتصال به واقعیت</h3>

      <p>
        Grounding یعنی مدل را به اطلاعات واقعی وصل کنی:
      </p>

      <ul>
        <li>دیتابیس</li>
        <li>API</li>
        <li>فایل‌ها</li>
        <li>اسناد</li>
        <li>دادهٔ علمی</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        در ربات‌های حرفه‌ای مثل Tavita Bot، Grounding باعث می‌شود مدل به جای حدس، واقعیت بگوید.
      </p>
    </section>

    <!-- مبحث ۸ -->
    <section id="section-5-8" class="section">
      <h3 class="section-title">مبحث ۸: Guardrails – ریل‌های محافظتی</h3>

      <p>
        Guardrails یعنی:
      </p>

      <ul>
        <li>چه موضوعی ممنوع است؟</li>
        <li>در شرایط خطر چه پاسخی بدهد؟</li>
        <li>چه کلمه‌هایی فیلتر شود؟</li>
        <li>درخواستی خلاف قوانین → رد شود.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        در ربات‌سازی Guardrails = امنیت محتوایی. ضروری و حیاتی است.
      </p>
    </section>

    <!-- مبحث ۹ -->
    <section id="section-5-9" class="section">
      <h3 class="section-title">مبحث ۹: Self-checking – بررسی و اصلاح توسط مدل</h3>

      <p>
        Self-checking یعنی از مدل بخواهی:
      </p>

      <blockquote>
        «خروجی بالا را بررسی کن. اگر اشتباهی هست، اصلاح کن.»
      </blockquote>

      <p>
        در این حالت مدل:
      </p>

      <ul>
        <li>خطاها را تشخیص می‌دهد،</li>
        <li>نسخهٔ دقیق‌تر ارائه می‌دهد،</li>
        <li>کیفیت خروجی را بالا می‌برد.</li>
      </ul>

      <h4>🔵 توضیح طاویتا</h4>
      <p>
        این تکنیک برای پژوهش و داده‌های حساس بسیار مهم است.
      </p>
    </section>

    <!-- مبحث ۱۰ -->
    <section id="section-5-10" class="section">
      <h3 class="section-title">مبحث ۱۰: جمع‌بندی فصل پنجم</h3>

      <ul>
        <li>مدل‌ها محدودند → حقیقت را «نمی‌دانند».</li>
        <li>Hallucination رایج است → باید مدیریت شود.</li>
        <li>کاهش خطا با CoT، محدودیت، Self-check و دمای پایین.</li>
        <li>Safety برای جلوگیری از سوءاستفاده ضروری است.</li>
        <li>Verification دقت خروجی را چند برابر می‌کند.</li>
        <li>Grounding اتصال به واقعیت است.</li>
        <li>Guardrails برای ربات‌سازی حیاتی‌اند.</li>
        <li>Self-checking بهترین ابزار پالایش خروجی است.</li>
      </ul>

      <p>
        این فصل مدل تو را از یک «ماشین پیش‌بینی» تبدیل می‌کند به «ابزار حرفه‌ای و قابل اعتماد».
      </p>
    </section>

  </div>
</article>

<!-- فصل ششم -->
      <article id="chapter-2" class="chapter">
        <div class="chapter-header">
          <h2 class="chapter-title">فصل دوم: عنوان فصل دوم</h2>
          <div class="chapter-toggle">＋</div>
        </div>
        <div class="chapter-body">
          <!-- مبحث ۱ -->
          <section id="section-2-1" class="section">
            <h3 class="section-title">مبحث ۱: عنوان مبحث اول فصل دوم</h3>
            <p>
              متن مبحث اول فصل دوم...
            </p>
          </section>

          <!-- مبحث ۲ -->
          <section id="section-2-2" class="section">
            <h3 class="section-title">مبحث ۲: عنوان مبحث دوم فصل دوم</h3>
            <p>
              متن مبحث دوم فصل دوم...
            </p>
          </section>
        </div>
      </article>

<!-- فصل هفتم -->
      <article id="chapter-2" class="chapter">
        <div class="chapter-header">
          <h2 class="chapter-title">فصل دوم: عنوان فصل دوم</h2>
          <div class="chapter-toggle">＋</div>
        </div>
        <div class="chapter-body">
          <!-- مبحث ۱ -->
          <section id="section-2-1" class="section">
            <h3 class="section-title">مبحث ۱: عنوان مبحث اول فصل دوم</h3>
            <p>
              متن مبحث اول فصل دوم...
            </p>
          </section>

          <!-- مبحث ۲ -->
          <section id="section-2-2" class="section">
            <h3 class="section-title">مبحث ۲: عنوان مبحث دوم فصل دوم</h3>
            <p>
              متن مبحث دوم فصل دوم...
            </p>
          </section>
        </div>
      </article>

<!-- فصل هشتم -->
      <article id="chapter-2" class="chapter">
        <div class="chapter-header">
          <h2 class="chapter-title">فصل دوم: عنوان فصل دوم</h2>
          <div class="chapter-toggle">＋</div>
        </div>
        <div class="chapter-body">
          <!-- مبحث ۱ -->
          <section id="section-2-1" class="section">
            <h3 class="section-title">مبحث ۱: عنوان مبحث اول فصل دوم</h3>
            <p>
              متن مبحث اول فصل دوم...
            </p>
          </section>

          <!-- مبحث ۲ -->
          <section id="section-2-2" class="section">
            <h3 class="section-title">مبحث ۲: عنوان مبحث دوم فصل دوم</h3>
            <p>
              متن مبحث دوم فصل دوم...
            </p>
          </section>
        </div>
      </article>


<!-- فصل نهم -->
      <article id="chapter-2" class="chapter">
        <div class="chapter-header">
          <h2 class="chapter-title">فصل دوم: عنوان فصل دوم</h2>
          <div class="chapter-toggle">＋</div>
        </div>
        <div class="chapter-body">
          <!-- مبحث ۱ -->
          <section id="section-2-1" class="section">
            <h3 class="section-title">مبحث ۱: عنوان مبحث اول فصل دوم</h3>
            <p>
              متن مبحث اول فصل دوم...
            </p>
          </section>

          <!-- مبحث ۲ -->
          <section id="section-2-2" class="section">
            <h3 class="section-title">مبحث ۲: عنوان مبحث دوم فصل دوم</h3>
            <p>
              متن مبحث دوم فصل دوم...
            </p>
          </section>
        </div>
      </article>




      
    </section>
  </div>

  <script>
    const tocChapters = document.querySelectorAll(".toc-chapter");
    const sectionButtons = document.querySelectorAll(".section-btn");
    const chapters = document.querySelectorAll(".chapter");

    function openChapter(chapterId) {
      chapters.forEach(ch => {
        const isTarget = ch.id === chapterId;
        ch.classList.toggle("active", isTarget);
        const toggleIcon = ch.querySelector(".chapter-toggle");
        if (toggleIcon) {
          toggleIcon.textContent = isTarget ? "－" : "＋";
        }
      });
    }

    function openSection(chapterId, sectionId) {
      openChapter(chapterId);

      // فعال‌کردن دکمه در فهرست
      sectionButtons.forEach(btn => {
        const isTarget =
          btn.dataset.chapter === chapterId &&
          btn.dataset.section === sectionId;
        btn.classList.toggle("active", isTarget);
      });

      const sectionEl = document.getElementById(sectionId);
      if (sectionEl) {
        sectionEl.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }

    // باز و بسته کردن لیست مبحث‌ها برای هر فصل در فهرست
    tocChapters.forEach(ch => {
      const header = ch.querySelector(".toc-chapter-header");
      const toggleIcon = ch.querySelector(".toc-chapter-toggle");

      header.addEventListener("click", () => {
        const isOpen = ch.classList.contains("open");
        ch.classList.toggle("open", !isOpen);
        if (toggleIcon) {
          toggleIcon.textContent = isOpen ? "＋" : "－";
        }
      });
    });

    // کلیک روی مبحث در فهرست
    sectionButtons.forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation(); // نذار کلیک روی هدر فصل هم حساب بشه
        const chapterId = btn.dataset.chapter;
        const sectionId = btn.dataset.section;
        openSection(chapterId, sectionId);
      });
    });

    // کلیک روی هدر خود فصل (در بخش متن)
    chapters.forEach(ch => {
      const header = ch.querySelector(".chapter-header");
      const toggleIcon = ch.querySelector(".chapter-toggle");
      header.addEventListener("click", () => {
        const isActive = ch.classList.contains("active");
        ch.classList.toggle("active", !isActive);
        if (toggleIcon) {
          toggleIcon.textContent = isActive ? "＋" : "－";
        }
      });
    });

    // اگر خواستی یک فصل/مبحث به صورت پیش‌فرض باز باشد، این را فعال کن:
    // openSection("chapter-1", "section-1-1");
  </script>
</body>
</html>
